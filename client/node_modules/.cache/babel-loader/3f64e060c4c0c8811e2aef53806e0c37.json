{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helpers_1 = require(\"@turf/helpers\");\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\n\n\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return coord.geometry.coordinates;\n    }\n\n    if (coord.type === \"Point\") {\n      return coord.coordinates;\n    }\n  }\n\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return coord;\n  }\n\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n\nexports.getCoord = getCoord;\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\n\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  } // Feature\n\n\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    // Geometry\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n\n  throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n\nexports.getCoords = getCoords;\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\n\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\n    return true;\n  }\n\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n\n  throw new Error(\"coordinates must only contain numbers\");\n}\n\nexports.containsNumber = containsNumber;\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\n\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n\n  if (!value || value.type !== type) {\n    throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\n  }\n}\n\nexports.geojsonType = geojsonType;\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\n\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n  }\n\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\n  }\n}\n\nexports.featureOf = featureOf;\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\n\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n  }\n\n  for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n    var feature = _a[_i];\n\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\n    }\n  }\n}\n\nexports.collectionOf = collectionOf;\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\n\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n\n  return geojson;\n}\n\nexports.getGeom = getGeom;\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\n\nfunction getType(geojson, name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n\n  return geojson.type;\n}\n\nexports.getType = getType;","map":{"version":3,"sources":["/home/isnardo/rcr/rose-city-resource/client/node_modules/@turf/invariant/index.js"],"names":["Object","defineProperty","exports","value","helpers_1","require","getCoord","coord","Error","Array","isArray","type","geometry","coordinates","length","getCoords","coords","containsNumber","isNumber","geojsonType","name","featureOf","feature","collectionOf","featureCollection","_i","_a","features","getGeom","geojson","getType"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n"]},"metadata":{},"sourceType":"script"}